(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{UQSp:function(e,t,i){"use strict";t.a={name:"VueRemarkRoot",render:function(e){return e("div",null,this.$slots.default)}}},uTbJ:function(e,t,i){"use strict";i.r(t);var a=i("KHd+"),n=i("UQSp"),r=i("Kw5r");function o(e){return(o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}r.a.config.optionMergeStrategies;var s={VueRemarkRoot:n.a},l=function(e){var t=e.options.components=e.options.components||{},i=e.options.computed=e.options.computed||{};Object.keys(s).forEach((function(e){"object"===o(s[e])&&"function"==typeof s[e].render||"function"==typeof s[e]&&"function"==typeof s[e].options.render?t[e]=s[e]:i[e]=function(){return s[e]}}))},u=r.a.config.optionMergeStrategies,d="__vueRemarkFrontMatter",p={excerpt:null,title:"Subscription configuration and types",topic:"events",type:"explanation"};var c=function(e){e.options[d]&&(e.options[d]=p),r.a.util.defineReactive(e.options,d,p),e.options.computed=u.computed({$frontmatter:function(){return e.options[d]}},e.options.computed)},_=Object(a.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("VueRemarkRoot",[i("h1",{attrs:{id:"subscription-types-and-settings"}},[i("a",{attrs:{href:"#subscription-types-and-settings","aria-hidden":"true"}},[e._v("#")]),e._v("Subscription types and settings")]),i("p",[e._v("Depending on your need, you may choose between some different types of subscriptions for events.")]),i("p",[e._v("For simple testing, you may start with a regular subscription without setting any other parameters than the list of\nevent types you would like to receive.")]),i("p",[e._v("For most production usages, we would recommenced enabling manual acknowledgement and a subscription using queue name\nand durable name. This would allow you to ensure you don't drop any events while sharing load between the clients.")]),i("p",[e._v("Enabling manual acknowledgement would allow clients to rate limit traffic and ensure all events are properly processed,\nby e.g. only acking after it is stored in database.")]),i("p",[e._v("It is also recommended to design the event processing such that events may be processed out of order as that would allow\nenabling multiple in-flight messages.")]),i("h2",{attrs:{id:"start-position"}},[i("a",{attrs:{href:"#start-position","aria-hidden":"true"}},[e._v("#")]),e._v("Start position")]),i("p",[e._v("Our event server keeps 30 minutes of history.")]),i("p",[e._v("When your client connects, you may decide at which position it should start reading")]),i("h4",{attrs:{id:"options"}},[i("a",{attrs:{href:"#options","aria-hidden":"true"}},[e._v("#")]),e._v("Options")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("start_at_sequence")]),e._v(" Start at a given sequence number ("),i("code",{pre:!0},[e._v("0")]),e._v(" will read from oldest history)")]),i("li",[i("code",{pre:!0},[e._v("start_at_timestamp")]),e._v(" Start at the given timestamp")]),i("li",[i("code",{pre:!0},[e._v("start_at_time_delta")]),e._v(" Start at a given time offset, e.g. 5 minutes ago")]),i("li",[i("code",{pre:!0},[e._v("start_with_last_received")]),e._v(" Start with the last received event")])]),i("p",[e._v("If omitted the client will omit historical data and start reading new events only.")]),i("h2",{attrs:{id:"configuration"}},[i("a",{attrs:{href:"#configuration","aria-hidden":"true"}},[e._v("#")]),e._v("Configuration")]),i("h3",{attrs:{id:"manual-acks"}},[i("a",{attrs:{href:"#manual-acks","aria-hidden":"true"}},[e._v("#")]),e._v("Manual acks")]),i("p",[e._v("If enable, this will require clients to do a gRPC call to manual acknowledge events. If a event is not acknowledged\nwithin its timeout, it will be retransmitted.")]),i("p",[e._v("The event's metadata field "),i("code",{pre:!0},[e._v("is_redelivered")]),e._v(" will be set to true for the retransmitted event.")]),i("p",[e._v("If manual acks is not enabled, a event will be implicitly acked after the server has sent the gRPC message.\nIn case of gRPC issues, you may still get messages redelivered.")]),i("h4",{attrs:{id:"options-1"}},[i("a",{attrs:{href:"#options-1","aria-hidden":"true"}},[e._v("#")]),e._v("Options")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("enable")]),e._v(" Set to true if enabled")]),i("li",[i("code",{pre:!0},[e._v("timeout")]),e._v(" Set to the desired ack timeout")])]),i("h3",{attrs:{id:"max-in-flight"}},[i("a",{attrs:{href:"#max-in-flight","aria-hidden":"true"}},[e._v("#")]),e._v("Max in-flight")]),i("p",[e._v("The server will not send more than "),i("code",{pre:!0},[e._v("max_in_flight")]),e._v(" messages before they are acknowledged.\nIf your client has strict requirements to process all events in-order, this must be set to 1.")]),i("p",[e._v("This setting is most useful if combined with manual acks.")]),i("h2",{attrs:{id:"subscription-types"}},[i("a",{attrs:{href:"#subscription-types","aria-hidden":"true"}},[e._v("#")]),e._v("Subscription types")]),i("h3",{attrs:{id:"regular"}},[i("a",{attrs:{href:"#regular","aria-hidden":"true"}},[e._v("#")]),e._v("Regular")]),i("p",[e._v("The subscriptions remembers theirs position while the client is connected. That is, no information is kept on server\nafter disconnect.")]),i("p",[e._v("Will start reading from the the specified start position if specified.\nIf no start position is set, it will skip previous events.")]),i("h4",{attrs:{id:"mandatory-input"}},[i("a",{attrs:{href:"#mandatory-input","aria-hidden":"true"}},[e._v("#")]),e._v("Mandatory input")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("type")]),e._v(" List of event types")])]),i("h4",{attrs:{id:"optional-input"}},[i("a",{attrs:{href:"#optional-input","aria-hidden":"true"}},[e._v("#")]),e._v("Optional input")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("start_position")]),i("a",{attrs:{href:"#start-position"}},[e._v("Start position, one of")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("start_at_sequence")])]),i("li",[i("code",{pre:!0},[e._v("start_at_timestamp")])]),i("li",[i("code",{pre:!0},[e._v("start_at_time_delta")])]),i("li",[i("code",{pre:!0},[e._v("start_with_last_received")])])])]),i("li",[i("code",{pre:!0},[e._v("manual_ack")]),i("a",{attrs:{href:"#manual-acks"}},[e._v("Manual ack config")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("enable")]),e._v(" Enable manual ack (true/false)")]),i("li",[i("code",{pre:!0},[e._v("timeout")]),e._v(" Timeout before resending unacknowledged message")])])]),i("li",[i("code",{pre:!0},[e._v("max_in_flight")]),i("a",{attrs:{href:"#max-in-flight"}},[e._v("Max number of concurrent unacknowledged events")])])]),i("h3",{attrs:{id:"durable"}},[i("a",{attrs:{href:"#durable","aria-hidden":"true"}},[e._v("#")]),e._v("Durable")]),i("p",[e._v("The subscriptions remember their position even if the client disconnects.")]),i("p",[e._v("It will start from this position when it starts if the subscription is still present in the server (expires after 1h).")]),i("p",[e._v("This subscription identify itself by "),i("code",{pre:!0},[e._v("client_id")]),e._v(" + "),i("code",{pre:!0},[e._v("durable_name")])]),i("h4",{attrs:{id:"mandatory-input-1"}},[i("a",{attrs:{href:"#mandatory-input-1","aria-hidden":"true"}},[e._v("#")]),e._v("Mandatory input")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("type")]),e._v(" List of event types")]),i("li",[i("code",{pre:!0},[e._v("client_id")]),e._v(" Name of the client")]),i("li",[i("code",{pre:!0},[e._v("durable_name")]),e._v(" Name of the durable connection")])]),i("h4",{attrs:{id:"optional-input-1"}},[i("a",{attrs:{href:"#optional-input-1","aria-hidden":"true"}},[e._v("#")]),e._v("Optional input")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("start_position")]),i("a",{attrs:{href:"#start-position"}},[e._v("Start position, one of")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("start_at_sequence")])]),i("li",[i("code",{pre:!0},[e._v("start_at_timestamp")])]),i("li",[i("code",{pre:!0},[e._v("start_at_time_delta")])]),i("li",[i("code",{pre:!0},[e._v("start_with_last_received")])])])]),i("li",[i("code",{pre:!0},[e._v("manual_ack")]),i("a",{attrs:{href:"#manual-acks"}},[e._v("Manual ack config")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("enable")]),e._v(" Enable manual ack (true/false)")]),i("li",[i("code",{pre:!0},[e._v("timeout")]),e._v(" Timeout before resending unacknowledged message")])])]),i("li",[i("code",{pre:!0},[e._v("max_in_flight")]),i("a",{attrs:{href:"#max-in-flight"}},[e._v("Max number of concurrent unacknowledged events")])])]),i("h3",{attrs:{id:"queue"}},[i("a",{attrs:{href:"#queue","aria-hidden":"true"}},[e._v("#")]),e._v("Queue")]),i("p",[e._v("If two subscriptions share a queue name they are member of the same queue group.")]),i("p",[e._v("Any event published will only be sent to one of the connected clients, so this can be used to share load between\ntwo clients.")]),i("p",[e._v("If all connected clients are disconnected, position will be lost.\nIt will then start reading from the the specified start position if specified, or else skip previous events.")]),i("p",[e._v("If there are still some connected clients, it will ignore start position and start reading from their position.")]),i("h4",{attrs:{id:"mandatory-input-2"}},[i("a",{attrs:{href:"#mandatory-input-2","aria-hidden":"true"}},[e._v("#")]),e._v("Mandatory input")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("type")]),e._v(" List of event types")]),i("li",[i("code",{pre:!0},[e._v("client_id")]),e._v(" Name of the client")]),i("li",[i("code",{pre:!0},[e._v("queue_name")]),e._v(" Name of the queue (must be the same for all clients that should share load)")])]),i("h4",{attrs:{id:"optional-input-2"}},[i("a",{attrs:{href:"#optional-input-2","aria-hidden":"true"}},[e._v("#")]),e._v("Optional input")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("start_position")]),i("a",{attrs:{href:"#start-position"}},[e._v("Start position, one of")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("start_at_sequence")])]),i("li",[i("code",{pre:!0},[e._v("start_at_timestamp")])]),i("li",[i("code",{pre:!0},[e._v("start_at_time_delta")])]),i("li",[i("code",{pre:!0},[e._v("start_with_last_received")])])])]),i("li",[i("code",{pre:!0},[e._v("manual_ack")]),i("a",{attrs:{href:"#manual-acks"}},[e._v("Manual ack config")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("enable")]),e._v(" Enable manual ack (true/false)")]),i("li",[i("code",{pre:!0},[e._v("timeout")]),e._v(" Timeout before resending unacknowledged message")])])]),i("li",[i("code",{pre:!0},[e._v("max_in_flight")]),i("a",{attrs:{href:"#max-in-flight"}},[e._v("Max number of concurrent unacknowledged events")])])]),i("h3",{attrs:{id:"queuedurable"}},[i("a",{attrs:{href:"#queuedurable","aria-hidden":"true"}},[e._v("#")]),e._v("Queue/Durable")]),i("p",[e._v("A durable queue will keep state on the server even if all subscriptions member of the gueue group has\ndisconnected.")]),i("p",[e._v("Each connected client will get a share of the traffic as for queue, but you may resume reading from\nthe previous position even if all clients are disconnected.")]),i("h4",{attrs:{id:"mandatory-input-3"}},[i("a",{attrs:{href:"#mandatory-input-3","aria-hidden":"true"}},[e._v("#")]),e._v("Mandatory input")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("type")]),e._v(" List of event types")]),i("li",[i("code",{pre:!0},[e._v("durable_name")]),e._v(" Name of the durable connection")]),i("li",[i("code",{pre:!0},[e._v("queue_name")]),e._v(" Name of the queue (must be the same for all clients that should share load)")])]),i("h4",{attrs:{id:"optional-input-3"}},[i("a",{attrs:{href:"#optional-input-3","aria-hidden":"true"}},[e._v("#")]),e._v("Optional input")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("start_position")]),i("a",{attrs:{href:"#start-position"}},[e._v("Start position, one of")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("start_at_sequence")])]),i("li",[i("code",{pre:!0},[e._v("start_at_timestamp")])]),i("li",[i("code",{pre:!0},[e._v("start_at_time_delta")])]),i("li",[i("code",{pre:!0},[e._v("start_with_last_received")])])])]),i("li",[i("code",{pre:!0},[e._v("manual_ack")]),i("a",{attrs:{href:"#manual-acks"}},[e._v("Manual ack config")]),i("ul",[i("li",[i("code",{pre:!0},[e._v("enable")]),e._v(" Enable manual ack (true/false)")]),i("li",[i("code",{pre:!0},[e._v("timeout")]),e._v(" Timeout before resending unacknowledged message")])])]),i("li",[i("code",{pre:!0},[e._v("max_in_flight")]),i("a",{attrs:{href:"#max-in-flight"}},[e._v("Max number of concurrent unacknowledged events")])])])])}),[],!1,null,null,null);"function"==typeof l&&l(_),"function"==typeof c&&c(_);t.default=_.exports}}]);