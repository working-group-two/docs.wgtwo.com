{"hash":"cfb2a497552fd912c15e237322f6951da5fe44da","data":{"doc":{"title":"Listen for events","headings":[{"value":"How to listen for Events"}],"subtitles":[{"depth":1,"value":"How to listen for Events","anchor":"#how-to-listen-for-events"},{"depth":2,"value":"Overview","anchor":"#overview"},{"depth":2,"value":"Event types","anchor":"#event-types"},{"depth":4,"value":"Consent revoke","anchor":"#consent-revoke"},{"depth":4,"value":"Handset update","anchor":"#handset-update"},{"depth":4,"value":"Location update","anchor":"#location-update"},{"depth":4,"value":"Roaming","anchor":"#roaming"},{"depth":4,"value":"Sms","anchor":"#sms"},{"depth":4,"value":"Sms delivery report","anchor":"#sms-delivery-report"},{"depth":4,"value":"Voice","anchor":"#voice"},{"depth":4,"value":"Voicemail","anchor":"#voicemail"},{"depth":2,"value":"Listen for events","anchor":"#listen-for-events"},{"depth":2,"value":"Manual acknowledge","anchor":"#manual-acknowledge"},{"depth":2,"value":"Concepts","anchor":"#concepts"}],"roles":["THIRD_PARTY_DEVELOPER","OPERATOR"],"hideWarning":null,"sourceExamples":[{"file":"examples/grpcurl/thirdpartydev/events/get-events.sh","content":"# Access token must be obtained via the client credentials flow\ngrpcurl \\\n  -H \"Authorization: Bearer ${ACCESS_TOKEN}\"\\\n  -import-path . \\\n  -proto wgtwo/events/v0/events.proto \\\n  -d '\n  {\n    \"type\": [\"VOICE_EVENT\"]\n  }\n  ' \\\n  api.wgtwo.com:443 \\\n  wgtwo.events.v0.EventsService.Subscribe\n"},{"file":"examples/kotlin/thirdpartydev/events/src/main/kotlin/com/wgtwo/examples/thirdpartydev/events/GetEvents.kt","content":"package com.wgtwo.examples.thirdpartydev.events\n\nimport com.wgtwo.api.common.Environment\nimport com.wgtwo.api.v0.events.EventsProto\nimport com.wgtwo.api.v0.events.EventsServiceGrpc\nimport com.wgtwo.api.util.auth.Channels\nimport com.wgtwo.api.util.auth.BearerToken\nimport io.grpc.stub.StreamObserver\n\nprivate val channel = Channels.createChannel(Environment.PRODUCTION)\nprivate val credentials = BearerToken { \"MY_ACCESS_TOKEN\" } // Add your _client credentials_ access token (not user access token)\nprivate val stub = EventsServiceGrpc.newStub(channel).withCallCredentials(credentials)\n\nfun main() {\n    val request = EventsProto.SubscribeEventsRequest.newBuilder()\n        .addType(EventsProto.EventType.VOICE_EVENT)\n        .addType(EventsProto.EventType.VOICEMAIL_EVENT)\n        .build()\n    stub.subscribe(request, object : StreamObserver<EventsProto.SubscribeEventsResponse> {\n        override fun onNext(response: EventsProto.SubscribeEventsResponse) {\n            println(\"Received event of type: ${response.event.eventCase}\")\n        }\n\n        override fun onError(throwable: Throwable) {\n            println(\"Got error: ${throwable.message}\")\n            // TODO: Reconnect\n        }\n\n        override fun onCompleted() {\n            println(\"Connection closed by the server\")\n        }\n    })\n    // Wait for stream to close\n    try { Thread.currentThread().join() } catch (e: InterruptedException) {}\n}\n"},{"file":"examples/kotlin/thirdpartydev/events/src/main/kotlin/com/wgtwo/examples/thirdpartydev/events/GetEventsManualAck.kt","content":"package com.wgtwo.examples.thirdpartydev.events\n\nimport com.wgtwo.api.common.Environment\nimport com.wgtwo.api.v0.events.EventsProto\nimport com.wgtwo.api.v0.events.EventsServiceGrpc\nimport com.wgtwo.api.util.auth.Channels\nimport com.wgtwo.api.util.auth.BearerToken\nimport io.grpc.stub.StreamObserver\nimport com.google.protobuf.util.Durations\n\nprivate val channel = Channels.createChannel(Environment.PRODUCTION)\nprivate val credentials = BearerToken { \"MY_ACCESS_TOKEN\" } // Add your _client credentials_ access token (not user access token)\nprivate val stub = EventsServiceGrpc.newStub(channel).withCallCredentials(credentials)\n\nfun main() {\n    val request = EventsProto.SubscribeEventsRequest.newBuilder()\n        .addType(EventsProto.EventType.VOICE_EVENT)\n        .addType(EventsProto.EventType.VOICEMAIL_EVENT)\n        .setManualAck(EventsProto.ManualAckConfig.newBuilder()\n                .setEnable(true)\n                .setTimeout(Durations.fromSeconds(15))\n                .build()\n        )\n        .build()\n    stub.subscribe(request, object : StreamObserver<EventsProto.SubscribeEventsResponse> {\n        override fun onNext(response: EventsProto.SubscribeEventsResponse) {\n            println(\"Received event of type: ${response.event.eventCase}\")\n            acknowledge(response.event)\n        }\n\n        override fun onError(throwable: Throwable) {\n            println(\"Got error: ${throwable.message}\")\n            // TODO: Reconnect\n        }\n\n        override fun onCompleted() {\n            println(\"Connection closed by the server\")\n        }\n    })\n    // Wait for stream to close\n    try { Thread.currentThread().join() } catch (e: InterruptedException) {}\n}\n\nfun acknowledge(event: EventsProto.Event) {\n    val request = EventsProto.AckRequest.newBuilder()\n        .setSequence(event.metadata.sequence)\n        .setInbox(event.metadata.ackInbox)\n        .build()\n    stub.ack(request, object : StreamObserver<EventsProto.AckResponse> {\n        override fun onNext(response: EventsProto.AckResponse) {\n            println(\"Event successfully acknowledged\")\n        }\n\n        override fun onError(throwable: Throwable) {\n            println(\"Error acknowledging event: ${throwable.message}\")\n        }\n\n        override fun onCompleted() {}\n    })\n}\n"}]}},"context":{}}